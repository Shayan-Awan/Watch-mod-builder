import * as THREE from "three";

// Custom shader materials for advanced watch rendering effects
export class WatchShaderLibrary {
      // Brushed Metal Shader - Creates realistic brushed surface effect
        static createBrushedMetalShader(): THREE.ShaderMaterial {
                return new THREE.ShaderMaterial({
                          uniforms: {
                                    uTime: { value: 0.0 },
                                            uColor: { value: new THREE.Color(0xc0c0c0) },
                                                    uRoughness: { value: 0.3 },
                                                            uMetalness: { value: 0.9 },
                                                                    uBrushDirection: { value: new THREE.Vector2(1.0, 0.0) },
                                                                            uBrushIntensity: { value: 0.8 },
                                                                                    uEnvironmentMap: { value: null },
                                                                                            uLightPosition: { value: new THREE.Vector3(10, 10, 10) },
                                                                                                    uLightColor: { value: new THREE.Color(0xffffff) },
                                                                                                            uLightIntensity: { value: 1.0 },
                          },
                                vertexShader: `
                                        varying vec3 vNormal;
                                                varying vec3 vPosition;
                                                        varying vec2 vUv;
                                                                varying vec3 vWorldPosition;
                                                                        
                                                                        void main() {
                                                                                  vNormal = normalize(normalMatrix * normal);
                                                                                            vPosition = position;
                                                                                                      vUv = uv;
                                                                                                                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                                                                                                                          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                                                                                                                                `,
                                                                                                                                  fragmentShader: `
                                                                                                                                          uniform float uTime;
                                                                                                                                                  uniform vec3 uColor;
                                                                                                                                                          uniform float uRoughness;
                                                                                                                                                                  uniform float uMetalness;
                                                                                                                                                                          uniform vec2 uBrushDirection;
                                                                                                                                                                                  uniform float uBrushIntensity;
                                                                                                                                                                                          uniform samplerCube uEnvironmentMap;
                                                                                                                                                                                                  uniform vec3 uLightPosition;
                                                                                                                                                                                                          uniform vec3 uLightColor;
                                                                                                                                                                                                                  uniform float uLightIntensity;
                                                                                                                                                                                                                          
                                                                                                                                                                                                                          varying vec3 vNormal;
                                                                                                                                                                                                                                  varying vec3 vPosition;
                                                                                                                                                                                                                                          varying vec2 vUv;
                                                                                                                                                                                                                                                  varying vec3 vWorldPosition;
                                                                                                                                                                                                                                                          
                                                                                                                                                                                                                                                          // Noise function for brush pattern
                                                                                                                                                                                                                                                          //         float noise(vec2 st) {
                                                                                                                                                                                                                                                          //           return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                                                                                                                                                                                                                                                          //         }
                                                                                                                                                                                                                                                          //         
                                                                                                                                                                                                                                                          //         // Generate brush lines
                                                                                                                                                                                                                                                          //         float brushPattern(vec2 uv, vec2 direction) {
                                                                                                                                                                                                                                                          //           vec2 brushUv = uv * 200.0;
                                                                                                                                                                                                                                                          //           float brushLines = sin(dot(brushUv, direction) * 3.14159);
                                                                                                                                                                                                                                                          //           brushLines = smoothstep(-0.1, 0.1, brushLines);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Add some randomness to make it more realistic
                                                                                                                                                                                                                                                          //           float n = noise(uv * 50.0);
                                                                                                                                                                                                                                                          //           brushLines = mix(brushLines, n, 0.1);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           return brushLines;
                                                                                                                                                                                                                                                          //         }
                                                                                                                                                                                                                                                          //         
                                                                                                                                                                                                                                                          //         void main() {
                                                                                                                                                                                                                                                          //           vec3 normal = normalize(vNormal);
                                                                                                                                                                                                                                                          //           vec3 viewDirection = normalize(cameraPosition - vWorldPosition);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Calculate brush pattern
                                                                                                                                                                                                                                                          //           float brush = brushPattern(vUv, uBrushDirection);
                                                                                                                                                                                                                                                          //           brush = mix(1.0, brush, uBrushIntensity);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Modify roughness based on brush pattern
                                                                                                                                                                                                                                                          //           float dynamicRoughness = uRoughness * brush;
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Basic lighting calculation
                                                                                                                                                                                                                                                          //           vec3 lightDirection = normalize(uLightPosition - vWorldPosition);
                                                                                                                                                                                                                                                          //           float NdotL = max(dot(normal, lightDirection), 0.0);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Reflection calculation for environment mapping
                                                                                                                                                                                                                                                          //           vec3 reflectionDirection = reflect(-viewDirection, normal);
                                                                                                                                                                                                                                                          //           vec4 envColor = textureCube(uEnvironmentMap, reflectionDirection);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Combine base color with metallic reflection
                                                                                                                                                                                                                                                          //           vec3 baseColor = uColor;
                                                                                                                                                                                                                                                          //           vec3 metallicColor = mix(baseColor, envColor.rgb, uMetalness);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Apply lighting
                                                                                                                                                                                                                                                          //           vec3 finalColor = metallicColor * NdotL * uLightColor * uLightIntensity;
                                                                                                                                                                                                                                                          //           finalColor += metallicColor * 0.2; // Ambient lighting
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Apply brush effect to final color
                                                                                                                                                                                                                                                          //           finalColor *= brush;
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           gl_FragColor = vec4(finalColor, 1.0);
                                                                                                                                                                                                                                                          //         }
                                                                                                                                                                                                                                                          //       `,
                                                                                                                                                                                                                                                          //     });
                                                                                                                                                                                                                                                          //   }
                                                                                                                                                                                                                                                          // 
                                                                                                                                                                                                                                                          //   // Sunburst Dial Shader - Creates dynamic sunburst pattern
                                                                                                                                                                                                                                                          //   static createSunburstDialShader(): THREE.ShaderMaterial {
                                                                                                                                                                                                                                                          //     return new THREE.ShaderMaterial({
                                                                                                                                                                                                                                                          //       uniforms: {
                                                                                                                                                                                                                                                          //         uTime: { value: 0.0 },
                                                                                                                                                                                                                                                          //         uBaseColor: { value: new THREE.Color(0x000080) },
                                                                                                                                                                                                                                                          //         uHighlightColor: { value: new THREE.Color(0x4169e1) },
                                                                                                                                                                                                                                                          //         uCenter: { value: new THREE.Vector2(0.5, 0.5) },
                                                                                                                                                                                                                                                          //         uRayCount: { value: 120.0 },
                                                                                                                                                                                                                                                          //         uIntensity: { value: 0.8 },
                                                                                                                                                                                                                                                          //         uRotation: { value: 0.0 },
                                                                                                                                                                                                                                                          //       },
                                                                                                                                                                                                                                                          //       vertexShader: `
                                                                                                                                                                                                                                                          //         varying vec2 vUv;
                                                                                                                                                                                                                                                          //         varying vec3 vNormal;
                                                                                                                                                                                                                                                          //         varying vec3 vPosition;
                                                                                                                                                                                                                                                          //         
                                                                                                                                                                                                                                                          //         void main() {
                                                                                                                                                                                                                                                          //           vUv = uv;
                                                                                                                                                                                                                                                          //           vNormal = normalize(normalMatrix * normal);
                                                                                                                                                                                                                                                          //           vPosition = position;
                                                                                                                                                                                                                                                          //           gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                                                                                                                                                                                                                                          //         }
                                                                                                                                                                                                                                                          //       `,
                                                                                                                                                                                                                                                          //       fragmentShader: `
                                                                                                                                                                                                                                                          //         uniform float uTime;
                                                                                                                                                                                                                                                          //         uniform vec3 uBaseColor;
                                                                                                                                                                                                                                                          //         uniform vec3 uHighlightColor;
                                                                                                                                                                                                                                                          //         uniform vec2 uCenter;
                                                                                                                                                                                                                                                          //         uniform float uRayCount;
                                                                                                                                                                                                                                                          //         uniform float uIntensity;
                                                                                                                                                                                                                                                          //         uniform float uRotation;
                                                                                                                                                                                                                                                          //         
                                                                                                                                                                                                                                                          //         varying vec2 vUv;
                                                                                                                                                                                                                                                          //         varying vec3 vNormal;
                                                                                                                                                                                                                                                          //         varying vec3 vPosition;
                                                                                                                                                                                                                                                          //         
                                                                                                                                                                                                                                                          //         void main() {
                                                                                                                                                                                                                                                          //           vec2 centered = vUv - uCenter;
                                                                                                                                                                                                                                                          //           float angle = atan(centered.y, centered.x) + uRotation;
                                                                                                                                                                                                                                                          //           float radius = length(centered);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Create sunburst rays
                                                                                                                                                                                                                                                          //           float rayPattern = sin(angle * uRayCount) * 0.5 + 0.5;
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Create radial gradient
                                                                                                                                                                                                                                                          //           float radialGradient = 1.0 - smoothstep(0.0, 0.5, radius);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Combine patterns
                                                                                                                                                                                                                                                          //           float pattern = rayPattern * radialGradient;
                                                                                                                                                                                                                                                          //           pattern = mix(0.3, 1.0, pattern * uIntensity);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Mix colors based on pattern
                                                                                                                                                                                                                                                          //           vec3 finalColor = mix(uBaseColor, uHighlightColor, pattern);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Add some metallic sheen
                                                                                                                                                                                                                                                          //           vec3 viewDir = normalize(cameraPosition - vPosition);
                                                                                                                                                                                                                                                          //           float fresnel = pow(1.0 - dot(vNormal, viewDir), 2.0);
                                                                                                                                                                                                                                                          //           finalColor += fresnel * 0.1;
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           gl_FragColor = vec4(finalColor, 1.0);
                                                                                                                                                                                                                                                          //         }
                                                                                                                                                                                                                                                          //       ~<
                                                                                                                                                                                                                                                          //     });
                                                                                                                                                                                                                                                          //   }
                                                                                                                                                                                                                                                          // 
                                                                                                                                                                                                                                                          //   // Luminous Material Shader - Simulates lume effect
                                                                                                                                                                                                                                                          //   static createLuminousShader(): THREE.ShaderMaterial {
                                                                                                                                                                                                                                                          //     return new THREE.ShaderMaterial({
                                                                                                                                                                                                                                                          //       uniforms: {
                                                                                                                                                                                                                                                          //         uTime: { value: 0.0 },
                                                                                                                                                                                                                                                          //         uBaseColor: { value: new THREE.Color(0x00ff00) },
                                                                                                                                                                                                                                                          //         uGlowColor: { value: new THREE.Color(0x88ff88) },
                                                                                                                                                                                                                                                          //         uIntensity: { value: 1.0 },
                                                                                                                                                                                                                                                          //         uGlowIntensity: { value: 0.5 },
                                                                                                                                                                                                                                                          //         uPulseSpeed: { value: 2.0 },
                                                                                                                                                                                                                                                          //       },
                                                                                                                                                                                                                                                          //       vertexShader: `
                                                                                                                                                                                                                                                          //         varying vec2 vUv;
                                                                                                                                                                                                                                                          //         varying vec3 vNormal;
                                                                                                                                                                                                                                                          //         varying vec3 vPosition;
                                                                                                                                                                                                                                                          //         
                                                                                                                                                                                                                                                          //         void main() {
                                                                                                                                                                                                                                                          //           vUv = uv;
                                                                                                                                                                                                                                                          //           vNormal = normalize(normalMatrix * normal);
                                                                                                                                                                                                                                                          //           vPosition = position;
                                                                                                                                                                                                                                                          //           gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                                                                                                                                                                                                                                          //         }
                                                                                                                                                                                                                                                          //       `,
                                                                                                                                                                                                                                                          //       fragmentShader: `
                                                                                                                                                                                                                                                          //         uniform float uTime;
                                                                                                                                                                                                                                                          //         uniform vec3 uBaseColor;
                                                                                                                                                                                                                                                          //         uniform vec3 uGlowColor;
                                                                                                                                                                                                                                                          //         uniform float uIntensity;
                                                                                                                                                                                                                                                          //         uniform float uGlowIntensity;
                                                                                                                                                                                                                                                          //         uniform float uPulseSpeed;
                                                                                                                                                                                                                                                          //         
                                                                                                                                                                                                                                                          //         varying vec2 vUv;
                                                                                                                                                                                                                                                          //         varying vec3 vNormal;
                                                                                                                                                                                                                                                          //         varying vec3 vPosition;
                                                                                                                                                                                                                                                          //         
                                                                                                                                                                                                                                                          //         void main() {
                                                                                                                                                                                                                                                          //           // Create pulsing effect
                                                                                                                                                                                                                                                          //           float pulse = sin(uTime * uPulseSpeed) * 0.5 + 0.5;
                                                                                                                                                                                                                                                          //           pulse = mix(0.7, 1.0, pulse);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Base luminous color
                                                                                                                                                                                                                                                          //           vec3 luminousColor = uBaseColor * uIntensity * pulse;
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // ADD GLOW EFFECT AT EDGES
                                                                                                                                                                                                                                                          //           VEC# VIEWDir = normalize(cameraPosition - vPosition);
                                                                                                                                                                                                                                                          //           float fresnel = 1.0 - dot(vNormal, viewDir);
                                                                                                                                                                                                                                                          //           fresnel = pow(fresnel, 2.0);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           vec3 glowColor = uGlowColor * fresnel * uGlowIntensity * pulse;
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           vec3 finalColor = luminousColor + glowColor;
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           gl_FragColor = vec4(finalColor, 1.0);
                                                                                                                                                                                                                                                          //         }
                                                                                                                                                                                                                                                          //       `,
                                                                                                                                                                                                                                                          //       transparent: true,
                                                                                                                                                                                                                                                          //     });
                                                                                                                                                                                                                                                          //   }
                                                                                                                                                                                                                                                          // 
                                                                                                                                                                                                                                                          //   // Crystal Shader - Advanced glass/crystal material
                                                                                                                                                                                                                                                          //   static createCrystalShader(): THREE.ShaderMaterial {
                                                                                                                                                                                                                                                          //     return new THREE.ShaderMaterial({
                                                                                                                                                                                                                                                          //       uniforms: {
                                                                                                                                                                                                                                                          //         uTime: { value: 0.0 },
                                                                                                                                                                                                                                                          //         uEnvironmentMap: { value: null },
                                                                                                                                                                                                                                                          //         uRefractiveIndex: { value: 1.77 },
                                                                                                                                                                                                                                                          //         uTransmission: { value: 0.95 },
                                                                                                                                                                                                                                                          //         uThickness: { value: 2.0 },
                                                                                                                                                                                                                                                          //         uChromaticAberration: { value: 0.02 },
                                                                                                                                                                                                                                                          //       },
                                                                                                                                                                                                                                                          //       vertexShader: `
                                                                                                                                                                                                                                                          //         varying vec3 vNormal;
                                                                                                                                                                                                                                                          //         varying vec3 vPosition;
                                                                                                                                                                                                                                                          //         varying vec3 vWorldPosition;
                                                                                                                                                                                                                                                          //         varying vec2 vUv;
                                                                                                                                                                                                                                                          //         
                                                                                                                                                                                                                                                          //         void main() {
                                                                                                                                                                                                                                                          //           vNormal = normalize(normalMatrix * normal);
                                                                                                                                                                                                                                                          //           vPosition = position;
                                                                                                                                                                                                                                                          //           vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                                                                                                                                                                                                                                                          //           vUv = uv;
                                                                                                                                                                                                                                                          //           gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                                                                                                                                                                                                                                          //         }
                                                                                                                                                                                                                                                          //       `,
                                                                                                                                                                                                                                                          //       fragmentShader: `
                                                                                                                                                                                                                                                          //         uniform float uTime;
                                                                                                                                                                                                                                                          //         uniform samplerCube uEnvironmentMap;
                                                                                                                                                                                                                                                          //         uniform float uRefractiveIndex;
                                                                                                                                                                                                                                                          //         uniform float uTransmission;
                                                                                                                                                                                                                                                          //         uniform float uThickness;
                                                                                                                                                                                                                                                          //         uniform float uChromaticAberration;
                                                                                                                                                                                                                                                          //         
                                                                                                                                                                                                                                                          //         varying vec3 vNormal;
                                                                                                                                                                                                                                                          //         varying vec3 vPosition;
                                                                                                                                                                                                                                                          //         varying vec3 vWorldPosition;
                                                                                                                                                                                                                                                          //         varying vec2 vUv;
                                                                                                                                                                                                                                                          //         
                                                                                                                                                                                                                                                          //         void main() {
                                                                                                                                                                                                                                                          //           vec3 normal = normalize(vNormal);
                                                                                                                                                                                                                                                          //           vec3 viewDirection = normalize(cameraPosition - vWorldPosition);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Calculate refraction for RGB channels separately (chromatic aberration)
                                                                                                                                                                                                                                                          //           float eta = 1.0 / uRefractiveIndex;
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           vec3 refractionR = refract(-viewDirection, normal, eta - uChromaticAberration);
                                                                                                                                                                                                                                                          //           vec3 refractionG = refract(-viewDirection, normal, eta);
                                                                                                                                                                                                                                                          //           vec3 refractionB = refract(-viewDirection, normal, eta + uChromaticAberration);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Sample environment map for each channel
                                                                                                                                                                                                                                                          //           float r = textureCube(uEnvironmentMap, refractionR).r;
                                                                                                                                                                                                                                                          //           float g = textureCube(uEnvironmentMap, refractionG).g;
                                                                                                                                                                                                                                                          //           float b = textureCube(uEnvironmentMap, refractionB).b;
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           vec3 refractedColor = vec3(r, g, b);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Calculate reflection
                                                                                                                                                                                                                                                          //           vec3 reflectionDirection = reflect(-viewDirection, normal);
                                                                                                                                                                                                                                                          //           vec3 reflectedColor = textureCube(uEnvironmentMap, reflectionDirection).rgb;
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Fresnel effect
                                                                                                                                                                                                                                                          //           float fresnel = pow(1.0 - dot(viewDirection, normal), 3.0);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Mix reflection and refraction based on fresnel
                                                                                                                                                                                                                                                          //           vec3 finalColor = mix(refractedColor, reflectedColor, fresnel);
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           // Apply transmission
                                                                                                                                                                                                                                                          //           float alpha = 1.0 - uTransmission + fresnel * uTransmission;
                                                                                                                                                                                                                                                          //           
                                                                                                                                                                                                                                                          //           gl_FragColor = vec4(finalColor, alpha);
                                                                                                                                                                                                                                                          //         }
                                                                                                                                                                                                                                                          //       `,
                                                                                                                                                                                                                                                          //       transparent: true,
                                                                                                                                                                                                                                                          //       side: THREE.DoubleSide,
                                                                                                                                                                                                                                                          //     });
                                                                                                                                                                                                                                                          //   }
                                                                                                                                                                                                                                                          // 
                                                                                                                                                                                                                                                          //   // Update shader uniforms
                                                                                                                                                                                                                                                          //   static updateShaderTime(material: THREE.ShaderMaterial, time: number) {
                                                                                                                                                                                                                                                          //     if (material.uniforms.uTime) {
                                                                                                                                                                                                                                                          //       material.uniforms.uTime.value = time;
                                                                                                                                                                                                                                                          //     }
                                                                                                                                                                                                                                                          //   }
                                                                                                                                                                                                                                                          // 
                                                                                                                                                                                                                                                          //   static updateEnvironmentMap(
                                                                                                                                                                                                                                                          //     material: THREE.ShaderMaterial,
                                                                                                                                                                                                                                                          //     envMap: THREE.CubeTexture,
                                                                                                                                                                                                                                                          //   ) {
                                                                                                                                                                                                                                                          //     if (material.uniforms.uEnvironmentMap) {
                                                                                                                                                                                                                                                          //       material.uniforms.uEnvironmentMap.value = envMap;
                                                                                                                                                                                                                                                          //     }
                                                                                                                                                                                                                                                          //   }
                                                                                                                                                                                                                                                          // 
                                                                                                                                                                                                                                                          //   static updateLightPosition(
                                                                                                                                                                                                                                                          //     material: THREE.ShaderMaterial,
                                                                                                                                                                                                                                                          //     position: THREE.Vector3,
                                                                                                                                                                                                                                                          //   ) {
                                                                                                                                                                                                                                                          //     if (material.uniforms.uLightPosition) {
                                                                                                                                                                                                                                                          //       material.uniforms.uLightPosition.value = position;
                                                                                                                                                                                                                                                          //     }
                                                                                                                                                                                                                                                          //   }
                                                                                                                                                                                                                                                          // }
                                                                                                                                                                                                                                                          // 
                                                                                                                                                                                                                                                          // export default WatchShaderLibrary;
                                                                                                                                                                                                                                                          // }})}})}}}}}})}}}}})}}}}})}}}}`}`
                          }
                })
        }
}